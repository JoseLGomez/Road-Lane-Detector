#include "Kalman5.h"
///////////////////////////////////////////////////////////////////////////////
// Construction/Destruction
///////////////////////////////////////////////////////////////////////////////
CKalman5::CKalman5()
{
	Initialize(0, 0, 0, 0, 0, 0);
}


/**************************************************************************//**
 * @brief	Constructor.
 *
 * @author	David Geronimo (dgeronimo@cvc.uab.es)
 * @date	Mar 26, 2012
 *
 * @param	a_in					The in.
 * @param	b_in					The in.
 * @param	c_in					The in.
 * @param	d_in					The in.
 * @param	e_in					The in.
 * @param	maxDistanceThreshold	The maximum distance threshold.
 *****************************************************************************/
CKalman5::CKalman5(float a_in, float b_in, float c_in, float d_in, float e_in, float maxDistanceThreshold)
{
	Initialize(a_in, b_in, c_in, d_in, e_in, maxDistanceThreshold);
}


/**************************************************************************//**
 * @brief	Destructor.
 *
 * @author	David Geronimo (dgeronimo@cvc.uab.es)
 * @date	Mar 26, 2012
 *****************************************************************************/
CKalman5::~CKalman5()
{
	Finish();
}



///////////////////////////////////////////////////////////////////////////////
// Initialization/Finalization
///////////////////////////////////////////////////////////////////////////////


/**************************************************************************//**
 * @brief	Initializes this object.
 *
 * @author	David Geronimo (dgeronimo@cvc.uab.es)
 * @date	Mar 26, 2012
 *
 * @param	a_in					The in.
 * @param	b_in					The in.
 * @param	c_in					The in.
 * @param	d_in					The in.
 * @param	e_in					The in.
 * @param	maxDistanceThreshold	The maximum distance threshold.
 *****************************************************************************/
void CKalman5::Initialize(float a_in, float b_in, float c_in, float d_in, float e_in, float maxDistanceThreshold)
{
	m_maxDistanceThreshold = maxDistanceThreshold;

	SetIdentity(I);

	a = a_in;
	b = b_in;
	c = c_in;
	d = d_in;
	e = e_in;

	X(0,0)=a;
	X(1,0)=b;
	X(2,0)=c;
	X(3,0)=d;
	X(4,0)=e;
	X(5,0)=0;
	X(6,0)=0;
	X(7,0)=0;
	X(8,0)=0;
	X(9,0)=0;

	// We don't know what the error is at the beginning, so get the first measures
	P(0,0)=1; P(0,1)=0; P(0,2)=0; P(0,3)=0; P(0,4)=0; P(0,5)=0; P(0,6)=0; P(0,7)=0; P(0,8)=0; P(0,9)=0; 
	P(1,0)=0; P(1,1)=1; P(1,2)=0; P(1,3)=0; P(1,4)=0; P(1,5)=0; P(1,6)=0; P(1,7)=0; P(1,8)=0; P(1,9)=0; 
	P(2,0)=0; P(2,1)=0; P(2,2)=1; P(2,3)=0; P(2,4)=0; P(2,5)=0; P(2,6)=0; P(2,7)=0; P(2,8)=0; P(2,9)=0; 
	P(3,0)=0; P(3,1)=0; P(3,2)=0; P(3,3)=1; P(3,4)=0; P(3,5)=0; P(3,6)=0; P(3,7)=0; P(3,8)=0; P(3,9)=0; 
	P(4,0)=0; P(4,1)=0; P(4,2)=0; P(4,3)=0; P(4,4)=1; P(4,5)=0; P(4,6)=0; P(4,7)=0; P(4,8)=0; P(4,9)=0; 
	P(5,0)=0; P(5,1)=0; P(5,2)=0; P(5,3)=0; P(5,4)=0; P(5,5)=1; P(5,6)=0; P(5,7)=0; P(5,8)=0; P(5,9)=0; 
	P(6,0)=0; P(6,1)=0; P(6,2)=0; P(6,3)=0; P(6,4)=0; P(6,5)=0; P(6,6)=1; P(6,7)=0; P(6,8)=0; P(6,9)=0; 
	P(7,0)=0; P(7,1)=0; P(7,2)=0; P(7,3)=0; P(7,4)=0; P(7,5)=0; P(7,6)=0; P(7,7)=1; P(7,8)=0; P(7,9)=0; 
	P(8,0)=0; P(8,1)=0; P(8,2)=0; P(8,3)=0; P(8,4)=0; P(8,5)=0; P(8,6)=0; P(8,7)=0; P(8,8)=1; P(8,9)=0; 
	P(9,0)=0; P(9,1)=0; P(9,2)=0; P(9,3)=0; P(9,4)=0; P(9,5)=0; P(9,6)=0; P(9,7)=0; P(9,8)=0; P(9,9)=1; 

	// State transition
	A(0,0)=1; A(0,1)=0; A(0,2)=0; A(0,3)=0; A(0,4)=0; A(0,5)=0; A(0,6)=0; A(0,7)=0; A(0,8)=0; A(0,9)=0; 
	A(1,0)=0; A(1,1)=1; A(1,2)=0; A(1,3)=0; A(1,4)=0; A(1,5)=0; A(1,6)=0; A(1,7)=0; A(1,8)=0; A(1,9)=0; 
	A(2,0)=0; A(2,1)=0; A(2,2)=1; A(2,3)=0; A(2,4)=0; A(2,5)=0; A(2,6)=0; A(2,7)=0; A(2,8)=0; A(2,9)=0; 
	A(3,0)=0; A(3,1)=0; A(3,2)=0; A(3,3)=1; A(3,4)=0; A(3,5)=0; A(3,6)=0; A(3,7)=0; A(3,8)=0; A(3,9)=0; 
	A(4,0)=0; A(4,1)=0; A(4,2)=0; A(4,3)=0; A(4,4)=1; A(4,5)=0; A(4,6)=0; A(4,7)=0; A(4,8)=0; A(4,9)=0; 
	A(5,0)=0; A(5,1)=0; A(5,2)=0; A(5,3)=0; A(5,4)=0; A(5,5)=1; A(5,6)=0; A(5,7)=0; A(5,8)=0; A(5,9)=0; 
	A(6,0)=0; A(6,1)=0; A(6,2)=0; A(6,3)=0; A(6,4)=0; A(6,5)=0; A(6,6)=1; A(6,7)=0; A(6,8)=0; A(6,9)=0; 
	A(7,0)=0; A(7,1)=0; A(7,2)=0; A(7,3)=0; A(7,4)=0; A(7,5)=0; A(7,6)=0; A(7,7)=1; A(7,8)=0; A(7,9)=0; 
	A(8,0)=0; A(8,1)=0; A(8,2)=0; A(8,3)=0; A(8,4)=0; A(8,5)=0; A(8,6)=0; A(8,7)=0; A(8,8)=1; A(8,9)=0; 
	A(9,0)=0; A(9,1)=0; A(9,2)=0; A(9,3)=0; A(9,4)=0; A(9,5)=0; A(9,6)=0; A(9,7)=0; A(9,8)=0; A(9,9)=1; 

	// State to measurement
	H(0,0)=1; H(0,1)=0; H(0,2)=0; H(0,3)=0; H(0,4)=0; H(0,5)=0; H(0,6)=0; H(0,7)=0; H(0,8)=0; H(0,9)=0;
	H(1,0)=0; H(1,1)=1; H(1,2)=0; H(1,3)=0; H(1,4)=0; H(1,5)=0; H(1,6)=0; H(1,7)=0; H(1,8)=0; H(1,9)=0;
	H(2,0)=0; H(2,1)=0; H(2,2)=1; H(2,3)=0; H(2,4)=0; H(2,5)=0; H(2,6)=0; H(2,7)=0; H(2,8)=0; H(2,9)=0;
	H(3,0)=0; H(3,1)=0; H(3,2)=0; H(3,3)=1; H(3,4)=0; H(3,5)=0; H(3,6)=0; H(3,7)=0; H(3,8)=0; H(3,9)=0;
	H(4,0)=0; H(4,1)=0; H(4,2)=0; H(4,3)=0; H(4,4)=1; H(4,5)=0; H(4,6)=0; H(4,7)=0; H(4,8)=0; H(4,9)=0;

	// Process noise covariance
	Q(0,0)=1; Q(0,1)=0; Q(0,2)=0; Q(0,3)=-1; Q(0,4)= 0; Q(0,5)= 0; Q(0,6)= 0; Q(0,7)= 0; Q(0,8)= 0; Q(0,9)= 0; 
	Q(1,0)=0; Q(1,1)=1; Q(1,2)=0; Q(1,3)= 0; Q(1,4)=-1; Q(1,5)= 0; Q(1,6)= 0; Q(1,7)= 0; Q(1,8)= 0; Q(1,9)= 0; 
	Q(2,0)=0; Q(2,1)=0; Q(2,2)=1; Q(2,3)= 0; Q(2,4)= 0; Q(2,5)=-1; Q(2,6)= 0; Q(2,7)= 0; Q(2,8)= 0; Q(2,9)= 0; 
	Q(3,0)=1; Q(3,1)=0; Q(3,2)=0; Q(3,3)= 0; Q(3,4)= 0; Q(3,5)= 0; Q(3,6)= 0; Q(3,7)= 0; Q(3,8)= 0; Q(3,9)= 0; 
	Q(4,0)=0; Q(4,1)=1; Q(4,2)=0; Q(4,3)= 0; Q(4,4)= 0; Q(4,5)= 0; Q(4,6)= 0; Q(4,7)= 0; Q(4,8)= 0; Q(4,9)= 0; 
	Q(5,0)=0; Q(5,1)=0; Q(5,2)=1; Q(5,3)= 0; Q(5,4)= 0; Q(5,5)= 0; Q(5,6)= 0; Q(5,7)= 0; Q(5,8)= 0; Q(5,9)= 0; 
	Q(6,0)=0; Q(6,1)=0; Q(6,2)=1; Q(6,3)= 0; Q(6,4)= 0; Q(6,5)= 0; Q(6,6)= 0; Q(6,7)= 0; Q(6,8)= 0; Q(6,9)= 0; 
	Q(7,0)=0; Q(7,1)=0; Q(7,2)=1; Q(7,3)= 0; Q(7,4)= 0; Q(7,5)= 0; Q(7,6)= 0; Q(7,7)= 0; Q(7,8)= 0; Q(7,9)= 0; 
	Q(8,0)=0; Q(8,1)=0; Q(8,2)=1; Q(8,3)= 0; Q(8,4)= 0; Q(8,5)= 0; Q(8,6)= 0; Q(8,7)= 0; Q(8,8)= 0; Q(8,9)= 0; 
	Q(9,0)=0; Q(9,1)=0; Q(9,2)=1; Q(9,3)= 0; Q(9,4)= 0; Q(9,5)= 0; Q(9,6)= 0; Q(9,7)= 0; Q(9,8)= 0; Q(9,9)= 0; 

	// Measurement noise covariance
	R(0,0)=1; R(0,1)=0; R(0,2)=0; R(0,3)=0; R(0,4)=0;
	R(1,0)=0; R(1,1)=1; R(1,2)=0; R(1,3)=0; R(1,4)=0;
	R(2,0)=0; R(2,1)=0; R(2,2)=1; R(2,3)=0; R(2,4)=0;
	R(3,0)=0; R(3,1)=0; R(3,2)=0; R(3,3)=1; R(3,4)=0;
	R(4,0)=0; R(4,1)=0; R(4,2)=0; R(4,3)=0; R(4,4)=1;
}


/**************************************************************************//**
 * @brief	Finishes this object.
 *
 * @author	David Geronimo (dgeronimo@cvc.uab.es)
 * @date	Mar 26, 2012
 *****************************************************************************/
void CKalman5::Finish()
{
}


///////////////////////////////////////////////////////////////////////////////
// Functions: Public
///////////////////////////////////////////////////////////////////////////////


/**************************************************************************//**
 * @brief	Predicts this object.
 *
 * @author	David Geronimo (dgeronimo@cvc.uab.es)
 * @date	Mar 26, 2012
 *****************************************************************************/
void CKalman5::Predict()
{
	ProjectState();
	ProjectErrorCovariance();
}


/**************************************************************************//**
 * @brief	Corrects.
 *
 * @author	David Geronimo (dgeronimo@cvc.uab.es)
 * @date	Mar 26, 2012
 *
 * @param	a_in	The in.
 * @param	b_in	The in.
 * @param	c_in	The in.
 * @param	d_in	The in.
 * @param	e_in	The in.
 *****************************************************************************/
void CKalman5::Correct(float a_in, float b_in, float c_in, float d_in, float e_in)
{
	Z(0,0) = a_in;
	Z(1,0) = b_in;
	Z(2,0) = c_in;
	Z(3,0) = d_in;
	Z(4,0) = e_in;

	KalmanGain();
	UpdateEstimateFromMeasurement();
	UpdateErrorCovariance();

	a = X(0,0);
	b = X(1,0);
	c = X(2,0);
	d = X(3,0);
	e = X(4,0);
}



///////////////////////////////////////////////////////////////////////////////
// Functions: Kalman process
///////////////////////////////////////////////////////////////////////////////


/**************************************************************************//**
 * @brief	Project state.
 *
 * @author	David Geronimo (dgeronimo@cvc.uab.es)
 * @date	Mar 26, 2012
 *****************************************************************************/
void CKalman5::ProjectState()
{
	Mult(A, X, tmp101_1);			// AX
	Copy(tmp101_1, X);
}


/**************************************************************************//**
 * @brief	Project error covariance.
 *
 * @author	David Geronimo (dgeronimo@cvc.uab.es)
 * @date	Mar 26, 2012
 *****************************************************************************/
void CKalman5::ProjectErrorCovariance()
{
	Mult(A,P,tmp1010_1);			// AP
	MultTrans(tmp1010_1,A,tmp1010_2);// APA^t
	Add(tmp1010_2,Q,P);				// APA^t + Q
}


/**************************************************************************//**
 * @brief	Kalman gain.
 *
 * @author	David Geronimo (dgeronimo@cvc.uab.es)
 * @date	Mar 26, 2012
 *****************************************************************************/
void CKalman5::KalmanGain()
{
	Mult(H,P,tmp510_1);				// HP
	MultTrans(tmp510_1,H,tmp55_1);	// HPH^t
	Add(tmp55_1, R, tmp55_2);		// HPH^t+R
	Inverse(tmp55_2,tmp55_1);		// (HPH^t+R)^-1

	Mult(tmp55_2,tmp55_1,tmp55_3);

	MultTrans(P,H,tmp105_1);		// PH^t
	Mult(tmp105_1,tmp55_1,K);		// PH^t * (HPH^t+R)^-1
}


/**************************************************************************//**
 * @brief	Updates the estimate from measurement.
 *
 * @author	David Geronimo (dgeronimo@cvc.uab.es)
 * @date	Mar 26, 2012
 *****************************************************************************/
void CKalman5::UpdateEstimateFromMeasurement()
{
	Mult(H,X,tmp51_1);				// HX
	Subtract(Z,tmp51_1,tmp51_2);	// Z-HX
	Mult(K,tmp51_2,tmp101_1);		// K(Z-HX)
	Add(X,tmp101_1,tmp101_2);		// X+K(Z-HX)
	Copy(tmp101_2,X);
}


/**************************************************************************//**
 * @brief	Updates the error covariance.
 *
 * @author	David Geronimo (dgeronimo@cvc.uab.es)
 * @date	Mar 26, 2012
 *****************************************************************************/
void CKalman5::UpdateErrorCovariance()
{
	Mult(K,H,tmp1010_1);			// KH
	Subtract(I,tmp1010_1,tmp1010_2);// I-KH
	Mult(tmp1010_2,P,tmp1010_3);	// (I-KH)P
	Copy(tmp1010_3,P);
}
